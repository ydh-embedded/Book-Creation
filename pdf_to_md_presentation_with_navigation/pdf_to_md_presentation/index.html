<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF to Markdown Converter</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">

    <!-- LINK Stylesheet -->
    <link rel="stylesheet" href="./styles/style.css">

    <!-- LINK AJAX-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- LINK TESSERACT.JS fÃ¼r OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>

</head>

<body>
    <script>
        let thisIsUnused = 42;        // Sollte markiert werden
        let thisIsUsed = 24;
        console.log(thisIsUsed);
    </script>
    <script>
        let unusedTestVariable = 42; // Sollte rot unterstrichen werden
        let _ignoredVariable = 42;   // Wird ignoriert (wegen _)
    </script>
    <button class="back-button" onclick="goBack()">
        <i class="fas fa-arrow-left"></i>
    </button>
    <!-- SECTION PDF to Markdown Converter -->
    <div class="container">
        <div class="header">
            <h1 class="title">PDF to Markdown Converter</h1>
            <p class="subtitle">Transform your PDF documents into accessible Markdown format</p>
        </div>

        <div class="upload-section" id="uploadSection">
            <i class="fas fa-cloud-upload-alt upload-icon"></i>
            <div class="upload-text">Drag & drop your PDF file here</div>
            <div class="upload-subtext">or click to browse files (Max size: 50MB)</div>
            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                Choose PDF File
            </button>
            <input type="file" id="fileInput" class="file-input" accept=".pdf" onchange="handleFileSelect(event)">

            <div class="file-info" id="fileInfo">
                <div class="file-name" id="fileName"></div>
                <div class="file-size" id="fileSize"></div>
            </div>

            <div class="options-section" id="optionsSection">
                <h4 style="color: #00C3CC; margin-bottom: 15px;">Conversion Options:</h4>
                <div class="option-item">
                    <input type="checkbox" id="extractImages" checked>
                    <label for="extractImages">Extract images from PDF</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="useOCR" checked>
                    <label for="useOCR">Use OCR for scanned/image-based PDFs (slower but more accurate)</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="preserveFormatting" checked>
                    <label for="preserveFormatting">Preserve document structure and formatting</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="includeDiagnostics">
                    <label for="includeDiagnostics">Include diagnostic information in output</label>
                </div>
                <div class="option-item">
                    <input type="checkbox" id="debugMode">
                    <label for="debugMode">Enable debug mode (show detailed processing log)</label>
                </div>
            </div>

            <button class="process-button" id="processButton" onclick="processFile()">
                <i class="fas fa-cogs"></i> Convert to Markdown
            </button>
        </div>

        <div class="progress-section" id="progressSection">
            <div class="progress-text" id="progressText">Processing your PDF...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressDetails">Analyzing document...</div>
        </div>

        <div class="warning-section" id="warningSection">
            <i class="fas fa-exclamation-triangle warning-icon"></i>
            <div class="warning-title">Limited Text Extraction</div>
            <div id="warningMessage">Some content could not be extracted properly.</div>
            <button class="upload-button" onclick="continueWithOCR()" style="margin: 20px 10px;">
                <i class="fas fa-eye"></i> Try OCR
            </button>
            <button class="upload-button" onclick="showPartialResult()" style="margin: 20px 10px;">
                <i class="fas fa-check"></i> Use Partial Result
            </button>
        </div>

        <div class="error-section" id="errorSection">
            <i class="fas fa-exclamation-triangle error-icon"></i>
            <div class="error-title">Conversion Failed</div>
            <div id="errorMessage">An error occurred while processing your PDF.</div>
            <button class="upload-button" onclick="resetConverter()" style="margin-top: 20px;">
                Try Again
            </button>
        </div>

        <div class="result-section" id="resultSection">
            <div class="result-icon" style="text-align: center;">
                <i class="fas fa-check-circle"></i>
            </div>
            <div class="result-title">Conversion Completed!</div>

            <div class="diagnostic-info" id="debugConsole" style="display: none;">
                <h4><i class="fas fa-bug"></i> Debug Log:</h4>
                <div id="debugLog"
                    style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; white-space: pre-wrap;">
                </div>
            </div>

            <div class="diagnostic-info" id="diagnosticInfo" style="display: none;"></div>

            <div class="images-section" id="imagesSection" style="display: none;">
                <h4><i class="fas fa-images"></i> Extracted Images (<span id="imageCount">0</span>)</h4>
                <div class="button-group">
                    <button class="download-button download-all-images" onclick="downloadAllImages()">
                        <i class="fas fa-download"></i> Download All Images as ZIP
                    </button>
                </div>
                <div class="image-gallery" id="imageGallery"></div>
            </div>

            <div class="markdown-preview" id="markdownPreview"></div>

            <div class="button-group">
                <button class="download-button" id="downloadMarkdown" onclick="downloadMarkdown()">
                    <i class="fas fa-download"></i> Download Markdown
                </button>

                <button class="upload-button" onclick="copyToClipboard()" style="margin-left: 10px;">
                    <i class="fas fa-copy"></i> Copy to Clipboard
                </button>
            </div>

            <div class="button-group">
                <button class="upload-button" onclick="resetConverter()">
                    Convert Another PDF
                </button>
            </div>
        </div>
    </div>

    <!-- LINK JavaScript-->
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let selectedFile = null;
        let extractedMarkdown = '';
        let extractedImages = [];
        let pdfDocument = null;
        let diagnosticData = {};
        let debugLog = [];

        // Debug logging function
        function addDebugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            debugLog.push(logEntry);
            console.log(logEntry);

            // Update debug console if visible
            if (document.getElementById('debugMode').checked) {
                const debugConsole = document.getElementById('debugLog');
                if (debugConsole) {
                    debugConsole.textContent = debugLog.join('\n');
                    debugConsole.scrollTop = debugConsole.scrollHeight;
                }
            }
        }

        // File selection handling
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                selectedFile = file;
                showFileInfo(file);
            } else {
                alert('Please select a valid PDF file.');
            }
        }

        // Show file information
        function showFileInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const fileName = document.getElementById('fileName');
            const fileSize = document.getElementById('fileSize');
            const processButton = document.getElementById('processButton');
            const optionsSection = document.getElementById('optionsSection');

            fileName.textContent = file.name;
            fileSize.textContent = `Size: ${(file.size / 1024 / 1024).toFixed(2)} MB`;

            fileInfo.style.display = 'block';
            optionsSection.style.display = 'block';
            processButton.style.display = 'inline-block';
        }

        // Drag and drop handling
        const uploadSection = document.getElementById('uploadSection');

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');

            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                selectedFile = files[0];
                showFileInfo(files[0]);

                // Update file input
                const fileInput = document.getElementById('fileInput');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(files[0]);
                fileInput.files = dataTransfer.files;
            } else {
                alert('Please drop a valid PDF file.');
            }
        });

        // Process file with enhanced error handling and image extraction
        async function processFile() {
            if (!selectedFile) {
                alert('Please select a PDF file first.');
                return;
            }

            // Hide all sections first
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('warningSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('progressSection').style.display = 'block';

            try {
                updateProgress(5, 'Reading PDF file...');
                addDebugLog(`Starting PDF processing for: ${selectedFile.name} (${(selectedFile.size / 1024 / 1024).toFixed(2)} MB)`);

                // Convert file to array buffer
                const arrayBuffer = await selectedFile.arrayBuffer();
                addDebugLog(`File converted to array buffer, size: ${arrayBuffer.byteLength} bytes`);

                updateProgress(15, 'Loading PDF document...');
                addDebugLog('Initializing PDF.js document loader...');

                // Load PDF document with enhanced error handling
                const loadingTask = pdfjsLib.getDocument({
                    data: arrayBuffer,
                    enableXfa: true, // Enable XFA forms
                    standardFontDataUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/',
                    disableAutoFetch: false,
                    disableStream: false
                });

                pdfDocument = await loadingTask.promise;
                addDebugLog(`PDF loaded successfully! Pages: ${pdfDocument.numPages}, PDF version: ${pdfDocument.numPages > 0 ? 'valid' : 'invalid'}`);

                // Initialize diagnostic data
                diagnosticData = {
                    fileName: selectedFile.name,
                    fileSize: selectedFile.size,
                    totalPages: pdfDocument.numPages,
                    extractedPages: 0,
                    textCharacters: 0,
                    emptyPages: 0,
                    imagesFound: 0,
                    errors: [],
                    methods: [],
                    processingSteps: []
                };

                extractedImages = [];

                updateProgress(25, 'Analyzing document structure...');
                diagnosticData.processingSteps.push('Document loaded successfully');
                addDebugLog('Document structure analysis complete');

                // Extract images if requested
                if (document.getElementById('extractImages').checked) {
                    updateProgress(30, 'Extracting images...');
                    addDebugLog('Starting image extraction...');
                    try {
                        await extractImages();
                        diagnosticData.processingSteps.push(`Image extraction completed: ${extractedImages.length} images found`);
                        addDebugLog(`Image extraction completed: ${extractedImages.length} images found`);
                    } catch (imgError) {
                        addDebugLog(`Image extraction failed: ${imgError.message}`);
                        diagnosticData.errors.push(`Image extraction failed: ${imgError.message}`);
                        diagnosticData.processingSteps.push('Image extraction failed, continuing with text');
                    }
                } else {
                    addDebugLog('Image extraction disabled by user');
                }

                // Try standard text extraction
                updateProgress(50, 'Extracting text...');
                addDebugLog('Starting standard text extraction...');
                let textExtractionSuccessful = false;

                try {
                    const standardResult = await extractTextStandard();
                    addDebugLog(`Standard extraction result: success=${standardResult.success}, textLength=${standardResult.text?.length || 0}`);

                    if (standardResult.success && standardResult.text && standardResult.text.length > 100) {
                        // Standard extraction worked well
                        extractedMarkdown = standardResult.text;
                        diagnosticData.methods.push('Standard PDF text extraction');
                        diagnosticData.processingSteps.push('Standard text extraction successful');
                        textExtractionSuccessful = true;
                        addDebugLog('Standard text extraction successful');
                        updateProgress(100, 'Conversion completed!');
                        setTimeout(() => showResult(), 1000);
                    } else {
                        diagnosticData.processingSteps.push('Standard text extraction produced minimal content');
                        addDebugLog(`Standard extraction produced minimal content: ${standardResult.text?.length || 0} characters`);

                        // If we have images but minimal text, might be a scanned PDF
                        if (extractedImages.length > 0) {
                            diagnosticData.processingSteps.push('PDF appears to be image-based, OCR recommended');
                            addDebugLog('PDF appears to be image-based (scanned document)');
                        }
                    }
                } catch (textError) {
                    addDebugLog(`Standard text extraction failed: ${textError.message}`);
                    diagnosticData.errors.push(`Standard text extraction: ${textError.message}`);
                    diagnosticData.processingSteps.push('Standard text extraction failed');
                }

                // If standard extraction didn't work, try OCR
                if (!textExtractionSuccessful) {
                    if (document.getElementById('useOCR').checked) {
                        updateProgress(70, 'Trying OCR extraction...');
                        diagnosticData.processingSteps.push('Attempting OCR extraction');
                        addDebugLog('Starting OCR extraction (Tesseract.js)...');

                        try {
                            const ocrResult = await extractTextWithOCR();
                            addDebugLog(`OCR extraction result: success=${ocrResult.success}, textLength=${ocrResult.text?.length || 0}`);

                            if (ocrResult.success && ocrResult.text && ocrResult.text.length > 50) {
                                extractedMarkdown = ocrResult.text;
                                diagnosticData.methods.push('OCR text extraction');
                                diagnosticData.processingSteps.push('OCR extraction successful');
                                textExtractionSuccessful = true;
                                addDebugLog('OCR extraction successful');
                                updateProgress(100, 'Conversion completed with OCR!');
                                setTimeout(() => showResult(), 1000);
                            } else {
                                diagnosticData.processingSteps.push('OCR extraction also produced minimal content');
                                addDebugLog(`OCR also produced minimal content: ${ocrResult.text?.length || 0} characters`);
                            }
                        } catch (ocrError) {
                            addDebugLog(`OCR extraction failed: ${ocrError.message}`);
                            diagnosticData.errors.push(`OCR extraction: ${ocrError.message}`);
                            diagnosticData.processingSteps.push('OCR extraction failed');
                        }
                    } else {
                        diagnosticData.processingSteps.push('OCR disabled by user');
                        addDebugLog('OCR disabled by user - cannot attempt OCR extraction');
                    }
                }

                // If both methods failed, show warning or error based on what we have
                if (!textExtractionSuccessful) {
                    if (extractedImages.length > 0) {
                        // We have images but no text - show warning with images
                        extractedMarkdown = `# ${selectedFile.name.replace('.pdf', '')}\n\n*No readable text was found in this PDF, but ${extractedImages.length} images were extracted.*\n\n`;
                        diagnosticData.methods.push('Image extraction only');
                        diagnosticData.processingSteps.push('Showing partial result with images only');
                        addDebugLog(`No text extracted, but ${extractedImages.length} images found - showing partial result`);
                        showWarning(`Text extraction failed, but ${extractedImages.length} images were extracted. This might be a scanned document.`);
                    } else {
                        // Nothing was extracted
                        addDebugLog('No content could be extracted from PDF');
                        throw new Error('No content could be extracted from this PDF. It may be corrupted, password-protected, or contain only non-extractable content.');
                    }
                }

            } catch (error) {
                addDebugLog(`Fatal error during PDF processing: ${error.message}`);
                diagnosticData.errors.push(error.message);
                diagnosticData.processingSteps.push(`Fatal error: ${error.message}`);

                let errorMessage = 'Failed to process PDF: ';
                if (error.message.includes('Invalid PDF') || error.message.includes('corrupted')) {
                    errorMessage += 'The file appears to be corrupted or not a valid PDF.';
                } else if (error.message.includes('password') || error.message.includes('encrypted')) {
                    errorMessage += 'This PDF is password protected or encrypted.';
                } else if (error.message.includes('permission')) {
                    errorMessage += 'This PDF has copy protection enabled.';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage += 'Network error loading PDF.js resources. Please check your internet connection.';
                } else {
                    errorMessage += error.message;
                }

                showError(errorMessage);
            }
        }

        // Extract images from PDF
        async function extractImages() {
            console.log('Starting image extraction...');
            try {
                for (let pageNum = 1; pageNum <= pdfDocument.numPages; pageNum++) {
                    try {
                        const page = await pdfDocument.getPage(pageNum);

                        // Try to get operator list for image detection
                        const operatorList = await page.getOperatorList();
                        console.log(`Page ${pageNum}: Found ${operatorList.fnArray.length} operations`);

                        let pageImageCount = 0;

                        for (let i = 0; i < operatorList.fnArray.length; i++) {
                            if (operatorList.fnArray[i] === pdfjsLib.OPS.paintImageXObject) {
                                const imgName = operatorList.argsArray[i][0];
                                console.log(`Found image object: ${imgName} on page ${pageNum}`);

                                try {
                                    // Wait for image object to be available
                                    const imgObj = await page.objs.get(imgName);

                                    if (imgObj && imgObj.data && imgObj.width && imgObj.height) {
                                        console.log(`Image ${imgName}: ${imgObj.width}x${imgObj.height}, ${imgObj.data.length} bytes`);

                                        // Create canvas to convert image data
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');

                                        canvas.width = imgObj.width;
                                        canvas.height = imgObj.height;

                                        // Create ImageData from the raw data
                                        let imageData;
                                        if (imgObj.data instanceof Uint8ClampedArray) {
                                            imageData = new ImageData(imgObj.data, imgObj.width, imgObj.height);
                                        } else {
                                            // Convert regular array to Uint8ClampedArray
                                            const clampedData = new Uint8ClampedArray(imgObj.data);
                                            imageData = new ImageData(clampedData, imgObj.width, imgObj.height);
                                        }

                                        ctx.putImageData(imageData, 0, 0);

                                        // Convert to blob
                                        const blob = await new Promise(resolve => {
                                            canvas.toBlob(resolve, 'image/png', 1.0);
                                        });

                                        if (blob && blob.size > 1000) { // Filter out tiny images
                                            const imageInfo = {
                                                name: `image_page${pageNum}_${pageImageCount + 1}.png`,
                                                blob: blob,
                                                url: URL.createObjectURL(blob),
                                                page: pageNum,
                                                width: imgObj.width,
                                                height: imgObj.height,
                                                size: blob.size
                                            };

                                            extractedImages.push(imageInfo);
                                            diagnosticData.imagesFound++;
                                            pageImageCount++;
                                            console.log(`Successfully extracted image: ${imageInfo.name}`);
                                        } else {
                                            console.log(`Skipped small image: ${blob ? blob.size : 0} bytes`);
                                        }
                                    } else {
                                        console.log(`Image object ${imgName} has no valid data`);
                                    }
                                } catch (imgError) {
                                    console.warn(`Failed to extract image ${imgName}:`, imgError);
                                    diagnosticData.errors.push(`Image ${imgName}: ${imgError.message}`);
                                }
                            }
                        }

                        console.log(`Page ${pageNum}: Extracted ${pageImageCount} images`);

                    } catch (pageError) {
                        console.warn(`Failed to process page ${pageNum} for images:`, pageError);
                        diagnosticData.errors.push(`Image extraction page ${pageNum}: ${pageError.message}`);
                    }

                    const progress = 30 + (pageNum / pdfDocument.numPages) * 15;
                    updateProgress(progress, `Extracting images from page ${pageNum}/${pdfDocument.numPages}...`);
                }

                console.log(`Image extraction completed. Total images: ${extractedImages.length}`);

            } catch (error) {
                console.error('Image extraction failed:', error);
                diagnosticData.errors.push(`Image extraction: ${error.message}`);
                throw error; // Re-throw to be caught by calling function
            }
        }

        // Standard text extraction with image references
        async function extractTextStandard() {
            try {
                let markdownText = `# ${selectedFile.name.replace('.pdf', '')}\n\n`;
                let totalText = '';

                for (let pageNum = 1; pageNum <= pdfDocument.numPages; pageNum++) {
                    try {
                        const page = await pdfDocument.getPage(pageNum);
                        const textContent = await page.getTextContent();

                        let pageText = '';
                        let lastY = null;
                        let lastSize = null;

                        textContent.items.forEach((item) => {
                            const text = item.str.trim();
                            if (!text) return;

                            // Enhanced font detection
                            const fontSize = item.transform ? item.transform[0] : 12;
                            const y = item.transform ? item.transform[5] : 0;

                            // Line break detection
                            if (lastY !== null && Math.abs(y - lastY) > fontSize * 0.8) {
                                pageText += '\n';
                            }

                            // Heading detection
                            if (lastSize !== null && fontSize > lastSize * 1.3) {
                                pageText += '\n## ';
                            }

                            pageText += text + ' ';
                            lastY = y;
                            lastSize = fontSize;
                        });

                        // Add image references for this page
                        const pageImages = extractedImages.filter(img => img.page === pageNum);
                        if (pageImages.length > 0) {
                            pageText += '\n\n### Images on this page:\n\n';
                            pageImages.forEach(img => {
                                pageText += `![${img.name}](${img.name}) *(${img.width}x${img.height}px)*\n\n`;
                            });
                        }

                        if (pageText.trim()) {
                            markdownText += `## Page ${pageNum}\n\n${pageText.trim()}\n\n`;
                            diagnosticData.extractedPages++;
                            diagnosticData.textCharacters += pageText.length;
                        } else {
                            diagnosticData.emptyPages++;
                        }

                        totalText += pageText;

                        const progress = 50 + (pageNum / pdfDocument.numPages) * 35;
                        updateProgress(progress, `Processing page ${pageNum} of ${pdfDocument.numPages}...`);

                    } catch (pageError) {
                        diagnosticData.errors.push(`Page ${pageNum}: ${pageError.message}`);
                    }
                }

                const cleanMarkdown = cleanupMarkdown(markdownText);
                return {
                    success: totalText.length > 50,
                    text: cleanMarkdown
                };

            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // OCR text extraction for scanned PDFs
        async function extractTextWithOCR() {
            try {
                let markdownText = `# ${selectedFile.name.replace('.pdf', '')} (OCR)\n\n`;
                let totalText = '';

                for (let pageNum = 1; pageNum <= Math.min(pdfDocument.numPages, 10); pageNum++) { // Limit OCR to first 10 pages
                    try {
                        const page = await pdfDocument.getPage(pageNum);
                        const viewport = page.getViewport({ scale: 2.0 });

                        // Create canvas
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;

                        // Render page to canvas
                        await page.render({
                            canvasContext: context,
                            viewport: viewport
                        }).promise;

                        updateProgress(70 + (pageNum / Math.min(pdfDocument.numPages, 10)) * 25, `OCR processing page ${pageNum}...`);

                        // Extract text using OCR
                        const ocrResult = await Tesseract.recognize(canvas, 'eng+deu', {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    const progress = 70 + (pageNum / Math.min(pdfDocument.numPages, 10)) * 25 * (m.progress || 0);
                                    updateProgress(progress, `OCR processing page ${pageNum}: ${Math.round((m.progress || 0) * 100)}%`);
                                }
                            }
                        });

                        let pageText = ocrResult.data.text.trim();

                        // Add image references for this page
                        const pageImages = extractedImages.filter(img => img.page === pageNum);
                        if (pageImages.length > 0) {
                            pageText += '\n\n### Images on this page:\n\n';
                            pageImages.forEach(img => {
                                pageText += `![${img.name}](${img.name}) *(${img.width}x${img.height}px)*\n\n`;
                            });
                        }

                        if (pageText) {
                            markdownText += `## Page ${pageNum}\n\n${pageText}\n\n`;
                            totalText += pageText;
                            diagnosticData.extractedPages++;
                            diagnosticData.textCharacters += pageText.length;
                        } else {
                            diagnosticData.emptyPages++;
                        }

                    } catch (pageError) {
                        diagnosticData.errors.push(`OCR Page ${pageNum}: ${pageError.message}`);
                    }
                }

                const cleanMarkdown = cleanupMarkdown(markdownText);
                return {
                    success: totalText.length > 50,
                    text: cleanMarkdown
                };

            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Continue with OCR after warning
        async function continueWithOCR() {
            document.getElementById('warningSection').style.display = 'none';
            document.getElementById('progressSection').style.display = 'block';

            updateProgress(70, 'Starting OCR extraction...');

            const ocrResult = await extractTextWithOCR();

            if (ocrResult.success) {
                extractedMarkdown = ocrResult.text;
                diagnosticData.methods.push('OCR text extraction (after standard failed)');
                updateProgress(100, 'OCR conversion completed!');
                setTimeout(() => showResult(), 1000);
            } else {
                showError('OCR extraction also failed. This PDF may contain only images or have copy protection.');
            }
        }

        // Show partial result
        function showPartialResult() {
            document.getElementById('warningSection').style.display = 'none';
            showResult();
        }

        // Clean up markdown formatting
        function cleanupMarkdown(text) {
            return text
                .replace(/\n{3,}/g, '\n\n')
                .replace(/^(#{1,6})\s*(.+)$/gm, '$1 $2')
                .replace(/^#{1,6}\s*$/gm, '')
                .replace(/^[\u2022\u25CF\u25AA\u25AB\u25A0]\s*/gm, '- ')
                .replace(/^(\d+)[\.\)]\s*/gm, '$1. ')
                .replace(/[ \t]+/g, ' ')
                .split('\n').map(line => line.trim()).join('\n')
                .replace(/\n{3,}/g, '\n\n');
        }

        // Update progress
        function updateProgress(percentage, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');

            progressFill.style.width = percentage + '%';
            progressText.textContent = text;
            progressDetails.textContent = `${Math.round(percentage)}% complete`;
        }

        // Show result with diagnostics and images
        function showResult() {
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('resultSection').style.display = 'block';

            // Show markdown preview
            const preview = document.getElementById('markdownPreview');
            preview.textContent = extractedMarkdown;

            // Show images if any were extracted
            if (extractedImages.length > 0) {
                showExtractedImages();
            }

            // Show diagnostic information if requested
            if (document.getElementById('includeDiagnostics').checked) {
                const diagnosticDiv = document.getElementById('diagnosticInfo');
                diagnosticDiv.innerHTML = `
                    <h4>Diagnostic Information:</h4>
                    <p><strong>File:</strong> ${diagnosticData.fileName} (${(diagnosticData.fileSize / 1024 / 1024).toFixed(2)} MB)</p>
                    <p><strong>Pages:</strong> ${diagnosticData.totalPages} total, ${diagnosticData.extractedPages} extracted, ${diagnosticData.emptyPages} empty</p>
                    <p><strong>Text:</strong> ${diagnosticData.textCharacters} characters extracted</p>
                    <p><strong>Images:</strong> ${diagnosticData.imagesFound} images found and extracted</p>
                    <p><strong>Methods used:</strong> ${diagnosticData.methods.join(', ')}</p>
                    ${diagnosticData.errors.length > 0 ? `<p><strong>Errors:</strong> ${diagnosticData.errors.join('; ')}</p>` : ''}
                `;
                diagnosticDiv.style.display = 'block';
            }
        }

        // Show extracted images
        function showExtractedImages() {
            const imagesSection = document.getElementById('imagesSection');
            const imageGallery = document.getElementById('imageGallery');
            const imageCount = document.getElementById('imageCount');

            imageCount.textContent = extractedImages.length;
            imageGallery.innerHTML = '';

            extractedImages.forEach((image, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'image-preview';

                imageDiv.innerHTML = `
                    <img src="${image.url}" alt="${image.name}" />
                    <div class="image-info">
                        ${image.name}<br>
                        ${image.width}x${image.height}px<br>
                        ${(image.size / 1024).toFixed(1)} KB<br>
                        Page ${image.page}
                    </div>
                    <button class="download-button image-download" onclick="downloadImage(${index})">
                        <i class="fas fa-download"></i> Download
                    </button>
                `;

                imageGallery.appendChild(imageDiv);
            });

            imagesSection.style.display = 'block';
        }

        // Download single image
        function downloadImage(index) {
            const image = extractedImages[index];
            const a = document.createElement('a');
            a.href = image.url;
            a.download = image.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Download all images as ZIP (simplified version)
        function downloadAllImages() {
            if (extractedImages.length === 0) {
                alert('No images to download');
                return;
            }

            // For simplicity, download images individually
            // In a real implementation, you'd use JSZip library
            extractedImages.forEach((image, index) => {
                setTimeout(() => downloadImage(index), index * 500);
            });

            alert(`Downloading ${extractedImages.length} images individually...`);
        }

        // Show warning
        function showWarning(message) {
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('warningSection').style.display = 'block';
            document.getElementById('warningMessage').textContent = message;
        }

        // Download markdown file
        function downloadMarkdown() {
            let content = extractedMarkdown;

            if (document.getElementById('includeDiagnostics').checked) {
                content += '\n\n---\n\n## Diagnostic Information\n\n';
                content += `- **File:** ${diagnosticData.fileName} (${(diagnosticData.fileSize / 1024 / 1024).toFixed(2)} MB)\n`;
                content += `- **Pages:** ${diagnosticData.totalPages} total, ${diagnosticData.extractedPages} extracted, ${diagnosticData.emptyPages} empty\n`;
                content += `- **Text:** ${diagnosticData.textCharacters} characters extracted\n`;
                content += `- **Images:** ${diagnosticData.imagesFound} images found and extracted\n`;
                content += `- **Methods used:** ${diagnosticData.methods.join(', ')}\n`;
                if (diagnosticData.errors.length > 0) {
                    content += `- **Errors:** ${diagnosticData.errors.join('; ')}\n`;
                }
            }

            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = selectedFile.name.replace('.pdf', '.md');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Copy to clipboard
        function copyToClipboard() {
            navigator.clipboard.writeText(extractedMarkdown).then(() => {
                const button = event.target.closest('button');
                const originalText = button.innerHTML;
                button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                setTimeout(() => {
                    button.innerHTML = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Show error
        function showError(message) {
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
        }

        // Reset converter
        function resetConverter() {
            selectedFile = null;
            extractedMarkdown = '';
            pdfDocument = null;
            diagnosticData = {};
            debugLog = [];

            // Clean up image URLs
            extractedImages.forEach(image => {
                URL.revokeObjectURL(image.url);
            });
            extractedImages = [];

            document.getElementById('fileInput').value = '';
            document.getElementById('fileInfo').style.display = 'none';
            document.getElementById('optionsSection').style.display = 'none';
            document.getElementById('processButton').style.display = 'none';
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('warningSection').style.display = 'none';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';

            document.getElementById('progressFill').style.width = '0%';

            // Clear debug console
            const debugLogElement = document.getElementById('debugLog');
            if (debugLogElement) {
                debugLogElement.textContent = '';
            }
        }

        // Go back to presentation
        function goBack() {
            window.location.href = 'index.html';
        }
    </script>
</body>

</html>